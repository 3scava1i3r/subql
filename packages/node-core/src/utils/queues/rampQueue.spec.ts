// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors
// SPDX-License-Identifier: GPL-3.0

import {Task} from './autoQueue';
import {RampQueue} from './rampQueue';

const testSizes = [
  4.448733415947499, 8.956082893010741, 1.0740251087438613, 7.874408027526685, 2.095588330681719, 9.877603058371257,
  0.26588775084013694, 5.3688758024204075, 4.671317302459488, 4.936036470903067, 7.463695662357379, 0.0711211590650418,
  4.841152155689485, 6.589399364540089, 5.33840341477309, 8.083555618831673, 0.9052566506797755, 5.9079018928373035,
  4.846492987181811, 8.245959543695747, 5.460921697188357, 0.7043806224121507, 2.3857434319496518, 2.6918821593173825,
  2.1284178622273875, 4.6586931023608, 5.541801214592789, 7.699660358512865, 1.7609267208636559, 7.374614871844476,
  3.467359287274774, 1.9130382916923239, 4.299989967525457, 8.700538279205558, 9.565834125047408, 1.8466949701526802,
  6.537691936703256, 1.768453891237669, 5.692631134946318, 8.628395051306788, 5.472044652806851, 9.927113870306119,
  4.003094529277136, 0.552330717827545, 3.5144104884478566, 7.449595823096287, 2.8985520335505566, 5.947189837345519,
  3.0711372037168583, 1.6113066655669672, 6.921119496961885, 4.719632718538214, 7.871754171657878, 7.955877161534463,
  3.397497333755941, 9.496938503818358, 1.3986331511241934, 5.622688974863552, 2.8435658149293097, 3.866639909234073,
  6.316575461599183, 3.141113012713883, 2.776692764764137, 5.831976543135431, 4.288044903146373, 6.048401548461621,
  2.6875146658212157, 6.822941828005713, 8.10971754598745, 0.3413062242535725, 8.897781544073045, 6.865489802832028,
  3.894256575593764, 5.862579766647702, 0.6062292779262113, 2.5020990968271106, 0.4564383819215645, 7.437457990684706,
  5.378929658223783, 6.404423211376513, 3.4856467856434903, 1.78756098752324, 5.06180877528712, 5.971995837564927,
  0.3329444767396139, 5.528156896524639, 2.6196190996965063, 6.971005783415343, 9.948474242499683, 3.011190899660412,
  8.133780227538313, 2.4909706549660715, 5.603675099720298, 5.136555674514199, 3.5004619769181144, 6.445875763339708,
  0.9132682345511878, 4.094728057715262, 8.94382906736585, 2.4066587617826785,
];

describe('RampQueue', () => {
  it('Ramps correctly', async () => {
    const queue = new RampQueue<number>((v: number) => v, 10, 100);

    // Initial should always be 1
    expect(queue.concurrency).toBe(1);

    await queue.put(() => Promise.resolve(10));

    // A single item shouldn't change the concurrenct
    expect(queue.concurrency).toBe(1);

    // Fill up to initial capacity
    const tasks: Task<number>[] = new Array(99).fill(0).map((_, i) => () => Promise.resolve(testSizes[i]));
    await Promise.all(queue.putMany(tasks));

    // Concurrency should still be one since capacity has only just been reached, from now we should be adjusting capacity
    // expect(queue.concurrency).toBe(1);

    const tasks1: Task<number>[] = new Array(100).fill(0).map((_, i) => () => Promise.resolve(testSizes[i]));
    await Promise.all(queue.putMany(tasks1));

    expect(queue.concurrency).toBe(7);
  });
});
